## 索引
索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。

### 索引的常见模型
哈希表、有序数组和搜索树

- 哈希：适用于等值查询（不适合区间查询）
哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。
    - 哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。
    - 哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。（不适合区间查询）

- 有序数组：有序数组索引只适用于静态存储引擎
二分法查询，时间复杂度是 O(log(N))。
优点:等值查询和范围查询场景中的性能就都非常优秀
缺点：更新数据成本代价高，往中间插入一个记录就必须得挪动后面所有的记录

- 搜索树
 - 二叉搜索树
查询时间复杂度是 O(log(N))。更新时为了平衡二叉树，时间复杂度也是 O(log(N))。
二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。
 - N叉树
在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。
为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。
以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。
N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中

“N叉树”的N值在MySQL中是可以被人工调整的么？
可以按照调整key的大小的思路来说；
如果你能指出来5.6以后可以通过page大小来间接控制应该能加分吧
面试回答不能太精减，计算方法、前缀索引什么的一起上

这里，“N 叉”树中的“N”取决于数据块的大小！！！N是由页大小和索引大小决定的。
以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。


### InnoDB 的索引模型-B+ 树索引模型
为什么要用B+树做索引？ B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。

B+树的叶子节点是page （页），一个页里面可以存多个行

索引定位到page，page内部有个有序数组去定位行数据，二分法

在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表

根据叶子节点的内容，索引类型分为主键索引和非主键索引。
主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。


#### 基于主键索引和普通索引的查询有什么区别？(普通索引需要回表，总共查询两次)
如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；

如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

#### 索引维护
页分裂：
插入新值时，如所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。
除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。
页合并:
当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。


##### 哪些场景下应该使用自增主键，而哪些场景下不应该?
主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。
所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。

用业务字段直接做主键的场景
KV 场景:只有一个索引；该索引必须是唯一索引。“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。

#### 重建索引的思考题 
对于上面例子中的 InnoDB 表 T，如果你要重建索引 k，你的两个 SQL 语句可以这么写：
altertable T dropindex k;
altertable T addindex(k);
如果你要重建主键索引，也可以这么写：
altertable T drop primary key;
altertable T add primary key(id);
我的问题是，对于上面这两个重建索引的作法，说出你的理解。如果有不合适的，为什么，更好的方法是什么？

通过两个 alter 语句重建索引 k，以及通过两个 alter 语句重建主键索引是否合理。
在评论区，有同学问到为什么要重建索引。我们文章里面有提到，索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。
这道题目，我给你的“参考答案”是：
重建索引 k 的做法是合理的，可以达到省空间的目的。
但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。
所以连着执行这两个语句的话，第一个语句就白做了。
这两个语句，你可以用这个语句代替 ： alter table T engine=InnoDB。


总结：
1.索引的作用：提高数据查询效率
2.常见索引模型：哈希表、有序数组、搜索树
3.哈希表：键 - 值(key - value)。
4.哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置
5.哈希冲突的处理办法：链表
6.哈希表适用场景：只有等值查询的场景
7.有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))
8.有序数组查询效率高，更新效率低
9.有序数组的适用场景：静态存储引擎。
10.二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子
11.二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))
12.数据库存储大多不适用二叉树，因为树高过高，会适用N叉树
13.InnoDB中的索引模型：B+Tree
14.索引类型：主键索引、非主键索引
主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)
15.主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)
16.一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。
17.从性能和存储空间方面考量，自增主键往往是更合理的选择。


例子：
在下面这个表 T 中，如果我执行 select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？
下面是这个表的初始化语句。
mysql> create table T(
ID int primary key,
k int NOT NULL DEFAULT 0,
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;
insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');

图 1 InnoDB 的索引组织结构
现在，我们一起来看看这条 SQL 查询语句的执行流程：
在 k 索引树上找到 k=3 的记录，取得 ID = 300；
再到 ID 索引树查到 ID=300 对应的 R3；
在 k 索引树取下一个值 k=5，取得 ID=500；
再回到 ID 索引树查到 ID=500 对应的 R4；
在 k 索引树取下一个值 k=6，不满足条件，循环结束。
在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，s
在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？

### 覆盖索引
如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据

### 最左前缀
联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符

### 联合索引
根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。

### 索引下推
索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

like 'hello%’and age >10 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。
5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度


##### 如果存在一个表每天生成300W数据, 且需要每天清除，有什么好的办法?
rename +新建表 ：rename 重建一个新的，然后找低峰期删掉旧的表

##### 怎么让mysql的myisam引擎支持事务?
不建议这样使用，原因如下：
用lock table 来实现，但是这样只能实现串行化隔离级别，其它隔离都实现不了。
但是因为mysiam不支持崩溃恢复，所以即使用lock table硬实现，也是问题多多：
ACID里面， 原子性和持久性做不到；
隔离性只能实现基本用不上的串行化；
一致性在正常运行的时候依赖于串行化，在异常崩溃的时候也不能保证。
这样实现的事务不要也罢。


##### 选择普通索引还是唯一索引？
###### 对于查询过程来说：
      a、普通索引，查到满足条件的第一个记录后，继续查找下一个记录，知道第一个不满足条件的记录
      b、唯一索引，由于索引唯一性，查到第一个满足条件的记录后，停止检索
      但是，两者的性能差距微乎其微。因为InnoDB根据数据页来读写的。
      
###### 对于更新过程来说：
      概念：change buffer
      当需要更新一个数据页，如果数据页在内存中就直接更新，
      如果不在内存中，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中。下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中的与这个页有关的操作。
     
change buffer是可以持久化的数据。在内存中有拷贝，也会被写入到磁盘上
      
      merge:将change buffer中的操作应用到原数据页上，得到最新结果的过程，成为merge
      访问这个数据页会触发merge，系统有后台线程定期merge，在数据库正常关闭的过程中，也会执行merge
      
      唯一索引的更新不能使用change buffer
      
      资料补充：唯一索引和普通索引在记录要更新的目标页不在内存中的InnoDB 的处理流程：
            对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
            对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。
            所以唯一索引用不了change buffer,因为都需要读入内存判断
      
      change buffer用的是buffer pool里的内存，change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。
      
      将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。
      change buffer 因为减少了随机磁盘访问，所以对更新性能的提升很明显。
      
 change buffer使用场景
      在一个数据页做purge之前，change buffer记录的变更越多，收益就越大。
      对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。
      
     反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer,但之后由于马上要访问这个数据页，会立即触发purge过程。
      这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。
      
 索引的选择和实践：
     尽可能使用普通索引。
     redo log主要节省的是随机写磁盘的IO消耗(转成顺序写)，而change buffer主要节省的则是随机读磁盘的IO消耗。
     
     首先，业务正确性优先。如果业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。
     然后，在一些“归档库”的场景，你是可以考虑使用普通索引的。比如，线上数据只需要保留半年，然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率，可以考虑把表里面的唯一索引改成普通索引。

补充说明:
1、changebuffer跟普通数据页一样也是存在磁盘里，区别在于changebuffer是在共享表空间ibdata1里
2、redolog有两种，一种记录普通数据页的改动，一种记录changebuffer的改动
3、只要内存里脏页（innodb buffer pool）里的数据发生了变化，就一定会记录2中前一种redolog
（对数据的修改记录在changebuffer里的时候，内存里是没有这个物理页的，不存在脏页）
3、真正对磁盘数据页的修改是通过将内存里脏页的数据刷回磁盘来完成的，而不是根据redolog



##### 思考题：
change buffer 开始是写内存的，那么如果这个时候机器掉电重启，会不会导致 change buffer 丢失呢？

change buffer是可以持久化的数据，在磁盘上占据了系统表空间ibdata，对应的内部系统表名为SYS_IBUF_TABLE。因此在异常关机的时候，不会丢失。

不会导致change buffer丢失，会导致本次未完成的操作数据丢失，但不会导致已完成操作的数据丢失。
1.change buffer中分两部分，一部分是本次写入未写完的，一部分是已经写入完成的。
2.针对未写完的，此部分操作，还未写入redo log，因此事务还未提交（会回滚），所以没影响。
2.针对，已经写完成的，可以通过redo log来进行恢复。
所以，不会对数据库造成影响。

（虽然是只更新内存，但是在事务提交的时候，我们把 change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来。）

merge 的过程是否会把数据直接写回磁盘？
merge 的执行流程是这样的：
从磁盘读入数据页到内存（老版本的数据页）；
从 change buffer 里找出这个数据页的 change buffer 记录 (可能有多个），依次应用，得到新版数据页；
写 redo log。这个 redo log 包含了数据的变更和 change buffer 的变更。
到这里 merge 过程就结束了。
这时候，数据页和内存中 change buffer 对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。


#### MySQL为什么有时候会选错索引？
1. mysql如何判断一个查询的扫描行数?
根据统计信息（索引的“区分度”）来估算记录数。
一个索引上不同的值的个数，我们称之为“基数”（cardinality）。基数越大，索引的区分度越好。

2. 索引基数如何计算? 通过哪个参数可以设置索引统计的存储方式?
2.1 采样统计
采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。
2.2 innodb_stats_persistent
可以通过设置参数 innodb_stats_persistent 的值来选择MySQL存储索引统计的方式：
    设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。
    设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。


3. 可以重新统计索引信息的命令是什么?
analyze table 表名

4. 如何定位索引选择异常这样的问题?
explain select * from t where xxx = xx
explain查看SQL的执行计划

5. 索引选择异常的问题可以有哪几种处理方式?
5.1 在应用端用 force index 来强行指定索引
5.2 通过修改语句来引导优化器
5.3 通过增加或者删除索引来绕过这个问题。

6. 怎么给字符串字段加索引？
6.1 直接创建完整索引，这样可能比较占用空间；
6.2 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；
6.3 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；
6.4 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。